# Proxy
代理模式


		1.什么是代理模式？
    
		为其他对象提供一种代理以控制对这个对象的访问。代理对象起到中介作用，可去掉功能服务或增加额外的服务。
		
		2.几种场景的代理模式：

		远程代理：为不同地理的对象，提供局域网代表对象。（例子：通过远程代理可以监控各个店铺，使之可以直观的了解店里的情况）

		虚拟代理：根据需要将资源消耗很大的对象进行延迟，真正需要的时候进行创建。

		保护代理：控制对一个物品的访问权限。

		智能引用代理：额外其他的服务（火车票代售处）：动态代理和静态代理。
		
		3.静态代理：代理和被代理对象在【代理之前】都是【确定】的。他们都实现【相同的接口或者继承相同的抽象类】
		
		静态代理实现方式：继承和聚合
		
		（1）继承：创建一个类（代理类）继承被代理类（实现相同的接口），在代理类中调用父类的被代理方法，在方法的前后增加代理的业务逻辑
	
		（2）聚合：一个类中调用另一个类的对象（两者实现相同接口）。在代理类中声明被代理类的对象，并通过构造方法将对象传进来（初始化）。在代理
	
	类的接口方法中调用被代理类对象
	
		---聚合代理优于继承代理。

		在实现功能叠加的情况下，聚合代理通过相互代理可以实现功能重用，而继承代理必须写多个类来实现多功能叠加。

		---但静态代理只能代理一种类型的被代理类，换个类型的就不行了，这需要动态代理
		
		4.动态代理：JDK动态代理和CGLIB动态代理
		
		（1）目的：动态产生代理，实现对【不同类】，【不同方法】的代理
		
		（2）java动态代理类，位于java.lang.reflect包下，一般涉及两个类：Proxy和InvocationHandler

		JDK动态代理是首先对象已经实现了某些接口，它是这样一种class：

		它是在运行时生成的class，该class需要实现一组interface，使用动态代理类时，必须实现InvocationHandler接口。
		
		动态代理实现的步骤：
		1)创建一个实现接口InvocationHandler的类，它必须实现invoke方法；
		2)创建被代理的类以及接口（就是在另外一个静态包里面以及定义过的Moveable和Car类了，被调用过来了）
		3)调用Proxy的静态方法，创建一个代理类：newProxyInstance(ClassLoader loader,Class[] interface,InvocationHandler h);
		4)通过代理调用方法    （m.move）
		
		5.CGlib代理： 
		
		JDK动态代理：只能对实现了接口的类实现代理 ，没有接口就不能实现JDK动态代理
		
		CGLIB动态代理：针对类产生子类，通过方法拦截技术拦截所有的父类方法的调用
		
		6.动态代理实现思路
		
		实现功能;通过Proxy的newProxyInstance返回代理对象
		1)声明一段源码(动态产生代理)
		2)编译源码(JDK Compiler API)，产生新的类(代理类)
		3)将这个类load到内存当中，产生一个新的对象(代理对象)
		4)return 代理对象
		
		总结回顾：
		1、代理概念、分类及应用场景
		为其他对象设置总代理，以控制对这个对象的访问；
		代理对象起到了中介的作用，去掉了某些功能，或增加了些额外的服务。
		四类：
		Remote Proxy -- 客户端服务器的模式
		Virtual Proxy -- 资源消耗很大，或复杂的对象，需要延迟，需要时创建，
		Protect Proxy -- 保护和控制权限
		Smart Reference Proxy -- 提供额外服务。

		为什么只讲智能引用代理？
		使用得多：日志处理、权限管理、事务处理...
		静态代理（继承、聚合）
		JDK动态代理实现日志处理的功能
		模拟JDK动态代理实现：在代理类Proxy和被代理类RealSubject之间，加入了invocationHandler。
		调用jar包中某个类的方法，不能改源码，AOP面向切面，增加额外事务逻辑。
